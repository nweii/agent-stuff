#!/usr/bin/env python3
# ABOUTME: Generates the skills/commands catalog section for README.md
# ABOUTME: Reads frontmatter descriptions and outputs markdown lists

import os
import re
from pathlib import Path

from typing import List, Tuple, Optional

REPO_ROOT = Path(__file__).parent.parent
README_PATH = REPO_ROOT / "README.md"
SKILLS_DIR = REPO_ROOT / "skills"
COMMANDS_DIR = REPO_ROOT / "commands"

START_MARKER = "<!-- CATALOG:START -->"
END_MARKER = "<!-- CATALOG:END -->"
def extract_frontmatter_field(content: str, field: str) -> Optional[str]:
    """Extract a field value from YAML frontmatter."""
    frontmatter_match = re.match(r"^---\s*\n(.*?)\n---", content, re.DOTALL)
    if not frontmatter_match:
        return None
    
    frontmatter = frontmatter_match.group(1)
    
    # Handle both quoted and unquoted values; allow indented keys (e.g. metadata.internal)
    pattern = rf'^\s*{field}:\s*["\']?(.*?)["\']?\s*$'
    match = re.search(pattern, frontmatter, re.MULTILINE)
    if match:
        return match.group(1).strip()
    return None


def get_skills() -> List[Tuple[str, str, str, bool]]:
    """Get all skills as a flat sorted list."""
    skills: List[Tuple[str, str, str, bool]] = []

    for skill_file in SKILLS_DIR.glob("*/SKILL.md"):
        # Skip private directory (gitignored)
        if skill_file.parent.name == "private":
            continue

        content = skill_file.read_text()
        desc = extract_frontmatter_field(content, "description")
        if not desc:
            desc = "(no description)"
            
        internal = extract_frontmatter_field(content, "internal")
        is_internal = str(internal).lower() == "true"

        name = skill_file.parent.name
        path = f"skills/{name}/"
        skills.append((name, path, desc, is_internal))

    skills.sort(key=lambda x: x[0])
    return skills


def get_commands() -> List[Tuple[str, str, str]]:
    """Get all commands as a flat sorted list."""
    commands: List[Tuple[str, str, str]] = []

    for cmd_file in COMMANDS_DIR.glob("*.md"):
        if cmd_file.parent.name == "private":
            continue

        content = cmd_file.read_text()
        desc = extract_frontmatter_field(content, "description")

        # Fall back to first non-heading paragraph if no frontmatter description
        if not desc:
            for line in content.strip().split("\n"):
                line = line.strip()
                if line and not line.startswith("#") and not line.startswith("---"):
                    desc = line
                    break
        if not desc:
            desc = "(no description)"

        name = cmd_file.stem
        path = f"commands/{cmd_file.name}"
        commands.append((name, path, desc))

    commands.sort(key=lambda x: x[0])
    return commands


def generate_catalog() -> str:
    """Generate the full catalog markdown."""
    lines = [
        "<!-- CATALOG:START -->",
        "",
        "_Auto-generated by `scripts/update-catalog.py`_",
        "",
        "### Skills",
        "",
        "[Internal] = personal workflows or vault-specific, likely needs adaptation.",
        "",
    ]
    
    for name, path, desc, is_internal in get_skills():
        if is_internal:
            lines.append(f"- [{name}]({path}) _[Internal]_ — {desc}")
        else:
            lines.append(f"- [{name}]({path}) — {desc}")
    lines.append("")
    
    lines.append("### Commands")
    lines.append("")
    
    for name, path, desc in get_commands():
        lines.append(f"- [{name}]({path}) — {desc}")
    lines.append("")
    
    lines.append("<!-- CATALOG:END -->")
    return "\n".join(lines)


def update_readme():
    """Update the README with the generated catalog."""
    readme_content = README_PATH.read_text()
    
    # Check for markers
    if START_MARKER not in readme_content or END_MARKER not in readme_content:
        print(f"Error: README.md missing catalog markers.")
        print(f"Add these markers where you want the catalog:")
        print(f"  {START_MARKER}")
        print(f"  {END_MARKER}")
        return False
    
    # Replace content between markers
    pattern = re.compile(
        rf"{re.escape(START_MARKER)}.*?{re.escape(END_MARKER)}",
        re.DOTALL
    )
    
    new_catalog = generate_catalog()
    new_content = pattern.sub(new_catalog, readme_content)
    
    README_PATH.write_text(new_content)
    print(f"Updated {README_PATH}")
    return True


if __name__ == "__main__":
    update_readme()
