#!/usr/bin/env python3
# ABOUTME: Generates the skills/commands catalog section for README.md
# ABOUTME: Reads frontmatter descriptions and outputs markdown lists

import os
import re
from pathlib import Path

REPO_ROOT = Path(__file__).parent.parent
README_PATH = REPO_ROOT / "README.md"
SKILLS_DIR = REPO_ROOT / "skills"
COMMANDS_DIR = REPO_ROOT / "commands"

START_MARKER = "<!-- CATALOG:START -->"
END_MARKER = "<!-- CATALOG:END -->"
def extract_frontmatter_field(content: str, field: str) -> str | None:
    """Extract a field value from YAML frontmatter."""
    frontmatter_match = re.match(r"^---\s*\n(.*?)\n---", content, re.DOTALL)
    if not frontmatter_match:
        return None
    
    frontmatter = frontmatter_match.group(1)
    
    # Handle both quoted and unquoted values
    pattern = rf'^{field}:\s*["\']?(.*?)["\']?\s*$'
    match = re.search(pattern, frontmatter, re.MULTILINE)
    if match:
        return match.group(1).strip()
    return None


def get_skills() -> dict[str, list[tuple[str, str, str]]]:
    """Get all skills organized by category."""
    skills_by_category: dict[str, list[tuple[str, str, str]]] = {}
    
    for skill_file in SKILLS_DIR.rglob("SKILL.md"):
        # Skip private directories (gitignored)
        if "private" in skill_file.parts:
            continue
            
        content = skill_file.read_text()
        desc = extract_frontmatter_field(content, "description")
        if not desc:
            desc = "(no description)"
        
        # Get category from path (e.g., "dev" or "personal")
        rel_path = skill_file.relative_to(SKILLS_DIR)
        parts = rel_path.parts
        category = parts[0] if len(parts) > 1 else "general"
        name = parts[-2]  # Folder name containing SKILL.md
        path = f"skills/{'/'.join(parts[:-1])}/"
        
        if category not in skills_by_category:
            skills_by_category[category] = []
        skills_by_category[category].append((name, path, desc))
    
    # Sort within each category
    for category in skills_by_category:
        skills_by_category[category].sort(key=lambda x: x[0])
    
    return skills_by_category


def get_commands() -> dict[str, list[tuple[str, str, str]]]:
    """Get all commands organized by category."""
    commands_by_category: dict[str, list[tuple[str, str, str]]] = {}
    
    for cmd_file in COMMANDS_DIR.rglob("*.md"):
        # Skip private directories (gitignored)
        if "private" in cmd_file.parts:
            continue
            
        content = cmd_file.read_text()
        desc = extract_frontmatter_field(content, "description")
        
        # Fall back to first paragraph if no frontmatter description
        if not desc:
            lines = content.strip().split("\n")
            for line in lines:
                line = line.strip()
                if line and not line.startswith("#") and not line.startswith("---"):
                    desc = line
                    break
        if not desc:
            desc = "(no description)"
        
        rel_path = cmd_file.relative_to(COMMANDS_DIR)
        parts = rel_path.parts
        
        # Determine category
        if len(parts) > 1:
            category = parts[0]
            name = parts[-1].replace(".md", "")
        else:
            category = "general"
            name = parts[0].replace(".md", "")
        
        path = f"commands/{rel_path}"
        
        if category not in commands_by_category:
            commands_by_category[category] = []
        commands_by_category[category].append((name, path, desc))
    
    # Sort within each category
    for category in commands_by_category:
        commands_by_category[category].sort(key=lambda x: x[0])
    
    return commands_by_category


def generate_catalog() -> str:
    """Generate the full catalog markdown."""
    lines = [
        "<!-- CATALOG:START -->",
        "",
        "_Auto-generated by `scripts/update-catalog.py`_",
        "",
        "### Skills",
        "",
    ]
    
    skills = get_skills()
    for category in sorted(skills.keys()):
        lines.append(f"**{category}**")
        lines.append("")
        for name, path, desc in skills[category]:
            lines.append(f"- [{name}]({path}) — {desc}")
        lines.append("")
    
    lines.append("### Commands")
    lines.append("")
    
    commands = get_commands()
    for category in sorted(commands.keys()):
        lines.append(f"**{category}**")
        lines.append("")
        for name, path, desc in commands[category]:
            lines.append(f"- [{name}]({path}) — {desc}")
        lines.append("")
    
    lines.append("<!-- CATALOG:END -->")
    return "\n".join(lines)


def update_readme():
    """Update the README with the generated catalog."""
    readme_content = README_PATH.read_text()
    
    # Check for markers
    if START_MARKER not in readme_content or END_MARKER not in readme_content:
        print(f"Error: README.md missing catalog markers.")
        print(f"Add these markers where you want the catalog:")
        print(f"  {START_MARKER}")
        print(f"  {END_MARKER}")
        return False
    
    # Replace content between markers
    pattern = re.compile(
        rf"{re.escape(START_MARKER)}.*?{re.escape(END_MARKER)}",
        re.DOTALL
    )
    
    new_catalog = generate_catalog()
    new_content = pattern.sub(new_catalog, readme_content)
    
    README_PATH.write_text(new_content)
    print(f"Updated {README_PATH}")
    return True


if __name__ == "__main__":
    update_readme()
